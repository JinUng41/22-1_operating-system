# 10장 가상 메모리

## 1. 물리 메모리의 한계

### 1.1 주소 공간과 물리 메모리

- 컴퓨터에 설치할 수 있는 물리 메모리의 최대 크기
    - 물리 메모리 최대 크기는 CPU 주소 버스 크기에 달려 있음
    - 32비트 물리 메모리 최대량 : 4GB = 2의 32승 byte
    - 64비트 … : 2의 24승TB
- 실제 컴퓨터에 설치되는 물리 메모리
    - 최대량에 미치지 못하는 크기, 비용 때문
    - 현재 대부분의 64비트 컴퓨터에서 8GB~32GB 수준

### 1.2 물리 메모리의 크기 한계

- 물리 메모리 크기 한계와 관련한 2가지 의문
    - 운영체제는 물리 메모리보다 큰 프로세스를 실행할 수 있는가?
    - 운영체제는 여러 프로세스를 합쳐 물리 메모리보다 클 때 이들을 동시에 실행시킬 수 있는가?
- 질문에 숨어 있는 전제
    - ‘프로세스 전체가 물리 메모리에 적재되야 한다.’
    - 이 전제를 부정하면서 당장 실행에 필요한 프로세스의 일부 메모리만 적재한 채 실행시킬 수는 없는가?

## 2. 가상 메모리 개념

물리 메모리 크기 한계를 극복하는 해결책

### 2.1 가상 메모리 개요

- 가상 메모리
    - 물리 메모리보다 큰 프로세스나 여러 개의 작은 프로세스를 동시에 실행시켜, 사용자나 응용프로그램에게 무한대의 메모리가 있다고 느끼도록 하는 메모리 관리 기법
- 가상 메모리 기법의 핵심
    - 물리 메모리를 디스크 공간으로 확장
    - 스와핑 swapping
        - 실행에 필요하지 않은 부분은 하드 디스크로 이동, 실행에 필요할 때 물리 메모리로 이동
- 가상 메모리 개념
    - 물리 메모리의 영역을 하드 디스크까지 연장
    - 프로세스 전체가 물리 메모리에 적재되어 있을 필요 없다
    - 물리 메모리에 빈 영역이 부족하게 되면, 물리 메모리의 일부분을 하드 디스크에 옮겨 물리 메모리의 빈 영역을 확보, 다중프로그래밍 정도(메모리에 적재하여 동시에 실행시키는 프로세스의 개수)를 높여 CPU 활용률을 높이고 시스템의 처리율을 높인다.
    - 스왑 영역 swap area : 물리 메모리를 확장하여 사용하는 디스크 영역
        - 스왑-아웃 swap-out : 물리 메모리의 일부를 디스크로 옮기는 작업
        - 스왑-인 swap-in : 스왑 영역으로부터 물리 메모리로 적재하는 과정
    - 사용자는 컴퓨터 시스템에 무한대에 가까운 물리 메모리가 있어 물리 메모리의 크기를 걱정하지 않고 큰 프로그램을 작성할 수 있다.
    - 가상 메모리는 운영체제마다 구현 방법이 다르다.
    
    ![Untitled](Untitled%2020.png)
    

### 2.2 가상 메모리 구현

- 가상 메모리 기법은 운영체제에서 2가지 방법으로 구현
    - 요구 페이징 demand paging
    - 요구 세그먼테이션 demand segmentation
- 요구 페이징
    - 프로세스의 일부 페이지들만 메모리에 적재하고 나머지는 하드 디스크에 두며, 페이지가 필요할 때 메모리를 할당받고 페이지를 적재시키는 메모리 관리 기법
    - = 페이징 + 스와핑
- 요구 세그먼테이션
    - 프로세스를 구성하는 일부 세그먼트들만 메모리에 적재해두고, 다른 세그먼트가 필요할 때 메모리를 할당받아 세그먼트를 적재하는 메모리 관리 기법
    - = 세그먼테이션 + 세그먼트 스와핑

### 2.3 가상 메모리 기법에 대한 의문들

- 스래싱 문제
    - 물리 메모리와 디스크의 스왑영역 사이에 입출력이 너무 빈번하게 발생하지 않는지?
- 페이지 테이블
    - 페이지 테이블은 어떻게 구성할지?
- 페이지 폴트
    - 가상 주소를 물리 주소로 변환할 때 페이지가 물리 메모리에 없는 경우 어떻게 처리할지?
- 페이지 할당
    - 프로세스의 어떤 페이지를 물리 메모리에 두고 어떤 페이지를 하드 디스크에 둘건지?
- 스왑 영역
    - 디스크의 스왑 영역 크기는 얼마가 적당한지?
- 프레임 할당
    - 메모리 프레임의 개수가 제한적이어서 프로세스별로 할당할 프레임의 개수를 몇 개로 정할지?
- 작업 집합
    - 프로세스는 일정 시간 범위에서 몇 개의 프레임을 실제로 사용하고 있는가?
- 페이지 교체 알고리즘
    - 필요한 페이지를 디스크로부터 읽어오기 위해 프레임 중 하나를 비워야 하는데 어떤 프레임을 비워야 하는지?, 비워야하는 프레임이 결정되면 그 프레임에 저장된 페이지는 어떻게 처리할 것인지?
- 쓰기 시 복사
    - 프로세스가 자식 프로세스를 생성하면 자식 프로세스의 메모리 공간은 어떻게 되는지?
    

## 3. 요구 페이징 demand paging

### 3.1 요구 페이징 개념

- ***요구 페이징***
    - 현재 실행에 필요한 일부 페이지들만 물리 메모리에 적재하고 나머지는 하드 디스크에 둠으로써 제한된 물리 메모리에 많은 프로세스를 실행시킨다.
        - 프로세스의 페이지가 있는 디스크 영역 : 스왑 영역 + 실행 파일
- 요구 페이징 구현
    - 운영체제는 첫 페이지만 물리 메모리에 적재하고, 실행 중 다음 페이지가 필요하면 그 때 적재시킴
    - 순수 요구 페이징
        - 아무 페이지도 물리 메모리에 적재하지 않은 채 프로세스 실행, 첫 페이지를 실행할 때 적재시키는 방법
    - 요구 demand의 의미
        - 페이지가 필요할 때 물리 메모리를 할당받고 디스크에서 읽어 적재
- 스왑 영역
    - 메모리에서 쫓겨난 페이지들이 저장되는 영역
        - 리눅스 : 디스크 내 특별한 위치 혹은 스왑 파티션에 구성
        - windows : C:/pagefile.sys 파일을 스왑 영역으로 사용
- 페이지 테이블
    - presence/valid 비트 - 페이지가 메모리에 적재되어 있는지를 나타내는 비트
        - 1이면 페이지가 물리 메모리에
        - 0이면 디스크에 있음
    - modified/dirty 비트 - 페이지가 메모리에 적재된 후 수정되었는지를 나타내는 비트
        - 1이면 해당 페이지가 물리 메모리에 적재된 후 수정, 나중에 쫓겨날 때 스왑-아웃
        - 0이면 수정된 적이 없으며 스왑 영역에 있는 상태와 동일함을 나타냄, 나중에 쫒겨날 때 스왑 영역 X
    - physical address 필드
        - presence bit=1일 때, 해당 페이지가 적재된 프레임 번호
        - presence bit=0일 때, 해당 페이지가 있는 디스크 블록 번호
- ***페이지 폴트 page fault***
    - CPU가 가상 주소를 발생시켜 액세스하려는 페이지가 현재 물리 메모리에 없을 때
        - 페이지 폴트가 일어나면 빈 프레임을 할당하고, 스왑 영역이나 실행 파일로부터 페이지 적재
    - swap-in, page-in
        - 스왑 영역으로부터 프레임에 적재
    - swap-out, page-out
        - 프레임에 적재된 페이지를 스왑 영역에 저장
    - page hit
        - CPU가 발생한 가상 주소의 페이지가 메모리 프레임에 있을 때

![Untitled](Untitled%2021.png)

### 3.3 페이지 폴트 자세히 알기 p472~474

- 페이지 폴트
    - 가상 주소의 페이지가 메모리 프레임에 없는 상황
    - MMU가 가상 주소를 물리 주소로 바꾸는 과정에서 발생
- 페이지 폴트가 발생하고 처리되는 과정

![Untitled](Untitled%2022.png)

- 결론 : 과정이 복잡하기 때문에 page fault는 적을수록 좋다

### 3.4 요구 페이징 시스템에서 프로세스 실행 p475~479

1. 프로세스의 시작 페이지 적재
    - 실행 파일로부터 프로세스의 실행이 시작될 첫 페이지 적재,  프로세스 실행
2. 여러 번의 페이지 폴트를 통해 실행 파일로부터 페이지들 적재
    - 폴트가 발생한 페이지는 다음 2개의 위치 중 있다.
        - 실행 파일
        - 스왑 영역
3. 메모리가 부족하면 스왑-아웃/스왑-인
4. 스왑-아웃된 페이지 다시 스왑-인
5. 수정된 페이지는 스왑 영역에 쓰기
    - m 비트=1일 때, 스왑 영역에 저장
    - m 비트=0일 때, 실행 파일에 저장

### 3.5 쓰기 시 복사 (cow, copy on write)

- 프로세스의 생성
    - 부모 프로세스가 fork() 시스템 호출로 생성
- fork()는 자식 프로세스의 메모리를 어떻게 형성하는가?
    - 완전 복사
        - 부모 프로세스의 모든 페이지를 완전히 복사
        - 비효율적 - fork() 후 exec()을 하는 것이 일반적이기 때문
    - 쓰기 시 복사
        - 부모 프로세스의 페이지 테이블만 복사
        - 초기에 자식 프로세스는 부모 프로세스의 메모리 프레임을 완전 공유
        - 자식 프로세스의 페이지 테이블 항목에 ‘쓰기 시 복사' 표시
        - 자식이나 부모 중 누군가 페이지를 수정할 때, 새로운 프레임을 할당 받아 공유하고 있는 부모 프레임을 복사
- 완전 복사

![Untitled](Untitled%2023.png)

- 완전 복사의 비효율성
    
    ![Untitled](Untitled%2024.png)
    
- 쓰기 시 복사로 자식 프로세스를 생성하는 과정
    
    ![Untitled](Untitled%2025.png)
    
- 쓰기 시 복사의 장점
    - 프로세스 생성 시간 절약
        - 부모 프로세스의 페이지 테이블만 복사하여 자식 프로세스를 생성하기 때문에 프로세스 생성이 매우 빠름
        - fork() 후 exec() 해도 프로세스 생성 과정에서 손해 없음
    - 메모리 절약
        - 부모, 자식 프로세스 모두 읽기만 하는 페이지는 새로운 프레임을 할당할 필요가 없으므로 메모리 절약

### 탐구 10-1 요구 페이징에 대해 생각해 볼 이슈

![Untitled](Untitled%2026.png)

### 3.6 페이지 폴트와 스래싱 thrashing

- 페이지 폴트와 디스크 I/O
    - 페이지 폴트가 발생하면 필연적으로 디스크 I/O가 동반된다.
- ***스래싱***
    - ***페이지 폴트가 계속 발생하여 메모리 프레임에 페이지가 반복적으로 교체되고 디스크 입출력이 심각하게 증가하고 CPU 활용률이 대폭 감소하는 현상***
    - ***빈번한 페이지 폴트로 인한 디스크 입출력 증가 현상***
- 스래싱의 원인
    - 다중프로그래밍 정도 (degree of multiprogramming, DOM)가 과도한 경우 발생
        - 프로세스가 필요한 페이지들을 충분히 적재하지 못하기 때문에 페이지 폴트가 발생할 가능성이 높아진다.
    - 메모리 할당 정책이나 페이지 교체 알고리즘이 잘못되었을 경우
    - 설치된 메모리가 절대적으로 작은 경우
    - 특정 시간대에 너무 많은 프로세스를 실행한 경우
- 스래싱 현상 관찰
    - 스래싱이 발생하는 시점
        - 다중프로그래밍 정도 (DOM)가 높아질수록 자연스러운 CPU 활용률 증가
        - DOM이 임계점 M을 넘어갈 때부터 예상과 달리 CPU의 활용률이 떨어지는 현상
            - CPU 활용률이 급감하고 I/O 비율 급상승
        
        ![Untitled](Untitled%2027.png)
        
- 스래싱 감지 및 해결 방법
    - 스래싱 감지
        - 운영체제에 따라 다름
        - 윈도우 : process explorer 등
        - 리눅스 : top나 htop, vmstat 명령을 통해 작업 부하는 높지만 CPU 활용률이 낮고, 스왑-인/아웃이 모두 높은지 검사
    - 스래싱 해결
        - DOM 줄이기
            - 몇몇 프로세스 종료
        - 하드 디스크 대신 빠른 SSD 사용
        - 메모리 늘리기

## 4. 참조의 지역성과 작업 집합

### 4.1 프로그램의 실행 특성

### 4.2 참조의 지역성

- ***참조의 지역성***
    - ***CPU가 프로그램을 실행하는 동안 짧은 시간 범위 내에 일정 구간의 메모리 영역을 반복 참조(액세스)하는 경향***
    - 참조의 지역성 특징
        - 프로그램이 가지는 기본적인 실행 특성
        - 메모리를 균일하게 참조되지 않고, 특정 부분이 집중 참조
        - 지역성 locality, 지역성의 원리 principle of locality 라고도 부른다.
        - 프로세스는 최근에 참조한 데이터와 코드를 다시 참조하는 경향이 있다.
        - 프로세스가 실행되는 동안 메모리 영역을 옮겨 다니면서 참조의 지역성이 나타난다.
        - 90/10 규칙 - 경험적 관찰에서 나온 것으로, “프로그램 코드의 10%가 프로그램 전체 실행 시간의 90%를 소비한다"라는 규칙
    - 의미
        - 현재 프로세스의 실행 패턴을 관찰하면, 가까운 미래에 프로세스의 코드와 데이터 사용을 합리적으로 예측 → 메모리 할당과 페이지 교체 전략에 활용
- 대표적인 참조의 지역성 형태
    - ***시간 지역성 temporal locality***
        - ***시간 면에서, 프로그램 내에 지금 참조되는 주소 혹은 페이지가 가까운 미래에 다시 참조될 가능성이 큰 특성***
        - ex) 반복문
    - ***공간 지역성 spatial locality***
        - ***공간(메모리 주소) 면에서, 지금 참조되는 주소의 주변 번지들(동일한 페이지)이 가까운 미래에 참조되는 특성***
        - ex) 배열, 순차 읽기/쓰기 등

### 4.3 작업 집합과 페이지 폴트

**작업 집합을 메모리에 유지시키는 것이 가상 메모리를 구현함에 있어 가장 중요하다. (페이지 폴트를 줄임으로써)**

- ***작업 집합 working set***
    - ***일정 시간 범위 내에 프로세스가 참조한(액세스한) 페이지들의 집합***
    - ***현재 프로세스의 실행에 필요한 페이지들의 집합***
        - 작업 집합이 포함된 페이지들이 모두 메모리에 적재되어 있을 때, 최고의 실행 성능
    - 참조의 지역성으로 인해 일정 시간 내에 작업 집합이 뚜렷하게 형성
        - 프로세스의 실행 중 갑자기 페이지 페이지 폴트가 계속되면, 작업 집합을 메모리에 적재하고 있는 과정 → 시간이 지나면 페이지 폴트가 줄고 작업 집합이 뚜렷하게 형성
        - 작업 집합 형성 과정
        
        ![Untitled](Untitled%2028.png)
        
- 작업 집합 이동
    - 프로세스가 실행되는 동안 계속 작업 집합 이동
        - 시간이 지나면 새로운 작업 집합 형성
        
        ![Untitled](Untitled%2029.png)
        
- 스래싱과 작업 집합
    - 1968년 Denning의 논문
    - 작업 집합에 포함된 페이지들이 충분히 메모리에 올라와 있지 않는 경우에 스래싱이 발생함
        - 각 프로세스에게 작업 집합 페이지들을 수용할 충분한 메모리를 할당하는 알고리즘을 통해 스래싱을 예방할 수 있음

### 4.4 요구 페이징의 필수 알고리즘

- 프레임 할당 frame allocation
    - 프로세스에게 할당할 메모리 프레임의 개수를 결정
- 페이지 교체 page replacement
    - 페이지 폴트가 발생하였을 때, 빈 메모리 프레임이 없는 경우 적재된 페이지들 중 스왑-아웃시킬 페이지를 선택하는 문제
    - 희생 프레임 선택

## 5. 프레임 할당

### 5.1 프레임 할당의 목표

프로세스에게 할당할 메모리 프레임의 개수를 결정

### 5.2 균당 할당과 비례 할당

- 균등 할당 equal allocation
    - 모든 프로세스에게 동일한 개수(=크기)의 프레임을 할당하는 방법
    - 장점 - 단순
    - 단점 - 작은 프로세스에는 프레임 낭비, 큰 프로세스에는 빈번한 페이지 폴트 발생 가능
- 비례 할당 proportional allocation
    - 프로세스의 크기에 비례하여 프레임을 할당하는 방법
    - 장점 - 페이지 폴트를 줄임
    - 단점 - 실행 전에 프로세스 크기를 알지 못함

### Tip. 프로세스에게 할당해야 할 최소 프레임 수

- 한 명령이 처리되는데 필요한 페이지의 개수
    - CPU 명령어의 주소 모드 addressing mode에 달려 있음
- 주소 모드에 따라 한 명령이 처리되는데 필요한 페이지의 개수 계산
    - mov eax, 23
        - 최소 1개의 페이지 (코드가 들어 있는)
    - mov eax, [mem addr]
        - 최소 2개의 페이지 (코드 1 + 데이터 1)
    - mov eax, [[mem addr]+5000]
        - 최소 3개의 페이지 (코드 1 + [mem addr] + [[mem_addr] + 50000])
- 주소 모드에 따라 한 명령이 최리되는데 필요한 페이지의 개수를 계산하는 것은 이론적

### 5.3 프로세스에게 할당할 적정 프레임 수

![Untitled](Untitled%2030.png)

### Tip. Windows의 프레임 할당 (작업 집합 관리) 사례

- windows는 프레임의 최소, 최대 수 (working set)을 정해 놓고 프로세스를 시작
- 프로세스 생성될 때
    - 최소/최대 working set 수 예약
    - 프로세스가 실행되면, 페이지 폴트 시 최소 수까지 메모리 할당 노력
    - 최대 수를 넘어서는 메모리 할당 불허
    - 가용 메모리가 충분하면, 프로세스에게 최대치를 넘어서도 할당
- 주기적으로
    - working set trimming algorithm으로 시스템 메모리 사용량을 스캔
    - 일정수준 이상 시스템 메모리가 사용되고 있으면, 프로세스들의 working set을 줄임 → 스왑아웃
    - windows가 정한 가용 메모리를 확보할 때까지 계속됨
- 프로세스가 스스로 작업 집합 크기를 변경할 수 있는 시스템 호출 제공

## 6. 페이지 교체

### 6.1 페이지 교체의 정의

- 페이지 교체란
    - 메모리 프레임 중 하나를 선택하여 비우고 이곳에 요청된 페이지를 적재하는 과정
    - 페이지 폴트 핸들러에 의해 실행
    - 희생 프레임 victim frame / 희생 페이지 victim page

### 6.2 페이지 교체의 목표

- 페이지 교체의 목표
    - 현재 작업 집합에 포함되지 않거나 가까운 미래에 참조되지 않을 페이지를 희생 페이지로 선택하여 페이지 폴트 횟수를 줄이는 것

### 6.3 희생 프레임의 선택 범위

- 지역 교체 local replacement
    - 페이지 적재를 요청한 프로세스에게 할당된 프레임들 중 희생 프레임을 선택하는 방법
    - per-process replacement
- 전역 교체 global replacement
    - 프로세스에 상관없이 전체 메모리 프레임 중에서 희생프레임을 선택하는 방법
    - 지역 교체보다 효과적
- 페이지 교체 알고리즘에 대한 시각 변화
    - RAM 용량이 커져 전역 교체 방법은 시간 소모가 너무 많다
    - CPU 캐시 활용이 중요해졌다
    - 참조의 지역성이 약화되어 객체지향언어의 사용으로 노드들의 연결리스트를 사용하는 형태로 바뀌고, 가비지 컬렉션을 기반으로…

### 6.4 페이지 교체 알고리즘 종류

- 최적 교체 optimal page replacement, OPT
    - 가장 먼 미래에 사용될 페이지
- FIFO first in first out
    - 가장 오래 적재된 페이지
- LRU least recently used
    - 가장 오래 사용되지 않은 페이지
- Clock
    - LRU를 단순화

### 6.5 최적 교체 알고리즘 OTP

- ***미래에 사용될 가능성이 가장 낮은 페이지***를 희생 페이지로 선택
- 구현
    - 페이지 폴트 횟수가 가장 적은 최고의 이상적인 방법
    - 미래에 언제 참조되는지 모두 알아야 구현이 가능하기 때문에 ***실현 불가능***
    - 최적 교체의 성능에 가까울수록 좋은 알고리즘으로 평가
        - 다른 알고리즘의 성능 평가에 사용

![Untitled](Untitled%2031.png)

### 6.6 FIFO 알고리즘

- ***가장 오래된 페이지***를 희생 페이지로 선택
- 구현
    - 적재된 시간 정보를 저장
    - 개념이 단순, 구현이 쉬움
    - 작업 집합을 고려하지 않음 → 성능이 낮음

![Untitled](Untitled%2032.png)

### 6.7 LRU 알고리즘

- ***가장 오래전에 참조된 페이지***를 희생 페이지로 선택
- 구현
    - 타임 스탬프 이용
        - 모든 프레임에 참조 시간을 기록할 수 있는 비트들을 추가
        - CPU가 페이지를 참조할 때마다 프레임에 현재 시간을 기록
        - 비효율적, 프레임 전체를 검색하는 것 또한 오버헤드
    - 하드웨어 이용, 참조 비트 사용
        - 페이지 테이블의 항목에 참조 비트 reference bit를 추가, 참조 비트가 0인 것들 중 하나를 선택
        - cpu가 주소를 발생할 때마다 페이지의 참조 비트를 1로 세팅
        - 시간 지연은 없도록 한다
        - 참조 비트가 0인 페이지를 찾아내기 위해 페이지 테이블을 모두 검색하는 시간과 커널에 의해 주기적으로 참조 비트를 0으로 초기화 하는데 많은 시간 소요
- LRU의 장단점
    - 성능이 좋게 평가
    - 구현의 복잡도가 높음
- 좋은 알고리즘으로 평가, 많은 OS에서 채택하고, 변형하여 사용

![Untitled](Untitled%2033.png)

### 6.8 Clock 알고리즘 (LRU 변형)

- LRU 근사 알고리즘 (LRU approximation), FIFO 근사 알고리즘, 2차 기회 알고리즘 (second chance)이라고도 한다.
- 구성
    - 메모리 프레임 당 1비트의 ***참조비트***를 사용, 프레임들을 원형 큐로 만들어 관리
    - ***포인터 (pointer, frame pointer)***
        - 원형 큐의 프레임 위치
- 동작 과정
    - 페이지 교체 요청이 발생, 포인터에서 시작하여 원형 큐를 따라 이동
        - 참조 비트 = 0, 희생 프레임으로 선택
        - 참조 비트 = 1, 0으로 바꾸고 다음 프레임으로 이동
        - 한 바퀴를 돌게 되면 처음 프레임 선택

![Untitled](Untitled%2034.png)