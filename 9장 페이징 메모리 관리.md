# 9장 페이징 메모리 관리

## 1. 페이징 메모리 관리 개요

### 1.1 페이징 개념

- 페이징
    - 프로세스의 주소 공간을 0번지부터 ***페이지***로 불리는 고정 크기로 나누고 물리 메모리도 0번지부터 페이지와 동일한 크기인 ***프레임***으로 나누어 프로세스의 각 페이즈를 물리 메모리의 프레임에 분산 할당하는 메모리 관리 기법
    - 대부분 4KB…8KB, 16KB 등
    - MMU
        - 논리 주소를 물리 주소로 변환
    - 내부 단편화 발생
    - 세그먼테이션보다 우수
- 페이지 테이블
    - 프로세스마다 만들어지며, 프로세스에 속한 모든 스레드는 실행 시 프로세스의 페이지 테이블을 이용
    - 페이지 번호와 프레임 번호를 1:1로 저장
- 페이징의 우수성
    - 용이한 구현 easy
    - 높은 이식성 portable
    - 높은 융통성 flexible
    - 메모리 활용과 시간 오버헤드 면에서 우수
        - 외부 단편화가 없다

### 1.2 페이지 테이블 사례 p422~425

(사례를 들어 설명하기 때문에 내용 생략, 주요 내용만 적겠음)

- 연속된 논리 주소는 페이징을 통해 분산된 물리 주소에 저장
- 커널 코드도 논리 주소로 되어 있으며, 시스템 호출을 통해 커널 코드가 실행될 때 현재  프로세스의 페이지 테이블을 이용하여 물리 주소로 변환된다.
    - 주소 변환은 MMU에 의해
    - 커널 페이지 테이블은 따로 없으며, 1개의 페이지 테이블이 사용자 주소 공간과 커널 공간 모두 관리
- ***페이지와 페이지 테이블에 대한 정리 (사진으로 대체)***

![Untitled](Untitled%207.png)

### 1.3 단편화

- 외부 단편화 X
- 내부 단편화 발생
    - 프로세스의 코드와 데이터가 주소 공간에 연속되어 있기 때문에 내부 단편화는 마지막 페이지에만 생긴다.
    - 단편화의 평균  크기 = 페이지의 1/2 크기

### 탐구 9-1 페이징 개념 확인

![Untitled](Untitled%208.png)

## 2. 페이징의 주소 체계

### 2.1 페이징의 논리 주소

- 논리 주소 구성
    - 논리 주소 = [ 페이지 번호(p), 옵셋(offset)]
    - 페이지 크기가 4KB(2의 12승)라면, 페이지 내 각 바이트 주소 (옵셋 주소)는 12비트
    - 32 비트 논리 주소 체계에서,
        - 상위 20비트는 페이지 번호
        - 하위 12비트는 옵셋

![Untitled](Untitled%209.png)

### 2.2 논리 주소의 물리 주소 변환

- 페이지 테이블을 통해 페이지 p가 할당된 프레임 번호 f를 얻을 수 있다.
- 페이지 번호를 프레임 번호로 바꾸고 옵셋은 그대로 사용하면 논리 주소를 물리 주소로 변환

![Untitled](Untitled%2010.png)

### 2.3 페이징 구현

- 하드웨어 지원
    - cpu 지원
        - cpu에 페이지 테이블이 적재된 물리 메모리 주소를 가진 레지스터, PTBR (page table base register)이 필요
        - 논리 주소를 물리 주소로 변환하기 위한 MMU 장치 (CPU 패키지에 내장)
    - 운영체제 지원
        - 물리 메모리의 빈 프레임 리스트를 생성하고 관리 유지하여, 메모리 프레임을 동적으로 할당/반환하는 기능
        - 페이지 테이블을 관리하고 페이지 테이블이 적재된 물리 메모리 주소를 PCB에 저장
        - 실행될 때마다 CPU내 PTBR 레지스터로 옮긴다

## 3. 페이지 테이블의 문제점과 TLB

### 3.1 페이지 테이블의 문제점

- ***2번의 물리 메모리 액세스***
    - cpu가 메모리를 액세스할 때마다, 2번의 물리 메모리 액세스 → 실행 속도를 저하시킨다.
    - ***페이지 테이블 항목 읽기 1번 + 데이터 액세스 1번***
    - TLB 사용으로 해결
- ***페이지 테이블의 낭비***
    - 프로세스의 실제 크기는 매우 작기 때문에 대부분의 페이지 테이블 항목이 비어있음
    - 멀티레벨 페이지 테이블 등의 방법으로 해결

### 3.2 2번의 물리 메모리 액세스

![Untitled](Untitled%2011.png)

### 탐구 9-2 C 프로그램이 실행될 때 메모리 액세스 과정 분석 p432~434

- 결론
    - 2번의 물리 메모리 액세스 → 심각한 성능 저하
    - 페이지 테이블 항목을 MMU 내에 저장해두면 어떨까?
        - 그 개념이 TLB

### 3.3 TLB를 이용한 2번의 물리 메모리 액세스 문제 해결

- ***TLB***
    - 주소 변환 캐시 address translation cache 라고도 함
    - ***최근에 액세스한 페이지 번호와 프레임 번호의 쌍을 저장하는 캐시 메모리***
    - MMU 내에 위치
    - 구조와 특징
        - [페이지 번호 p, 프레임 번호 f]를 항목으로 저장
        - 페이지 번호로 ***전체 캐시 (모든 항목) 를 동시에 고속 검색***, 프레임 번호 출력
        - 가격이 비쌈, 크기 작음 (64~1024개의 항목 저장)
    
    ![Untitled](Untitled%2012.png)
    
- TLB를 활용한 메모리 액세스 과정
    - cpu로부터 논리 주소 발생
    - 논리 주소의 페이지 번호가 TLB로  전달
    - 페이지 번호와 TLB내 모든 항목 동시에 비교
        - TLB hit, TLB miss
    
    ![Untitled](Untitled%2013.png)
    

### 탐구 9-3 TLB가 있는 경우 C 프로그램의 실행 과정 분석 p437~438

- 2가지 현상
    - 처음 TLB miss 발생하는 한 번의 경우에만 물리 메모리 2번 액세스
    - 동일한 페이지를 연속하여 액세스 하는 동안 TLB hit 계속 발생
- TLB를 활용하면 CPU의 메모리 액세스 성능이 좋아지는 이유

### 탐구 9-4 배열이 2개의 페이지에 걸쳐 있는 경우 TLB 활용 사례 p438~440

### TLB 결론

- TLB와 참조의 지역성
    - TLB는 ***순차 메모리 액세스 패턴***을 가진 프로그램에 매우 효과적
    - ***참조의 지역성 locality of reference***
        - 프로그램은 실행되는 동안 짧은 시간 범위 내에 일정 구간의 메모리 영역을 반복 액세스하는 경향이 있다.
    - TLB 사용 시, 순차 메모리 액세스 속도 빠름
        - TLB hit 계속됨
    - 랜덤 메모리 속도 느림
        - TLB miss 자주 발생, TLB 잦은 항목 교체
- TLB 성능
    - ***TLB 히트율 TLB hit ratio*** 높이기
        - TLB 항목 수를 늘리기 (비용과 trade-off)
    - 페이지 크기
        - 장점 : 클수록 히트율 증가 → 실행 성능 향상
        - 단점 :  내부 단편화 증가 → 메모리 낭비
        - 페이지 크기는 선택의 문제이나 디스크의 입출력의 성능 향상을 위해서 현대에서는 커지는 추세
    - ***TLB reach***
        - TLB 도달 범위
        - TLB 캐시의 모든 항목이 채워졌을 대 TLB miss 없이 작동하는 메모리 액세스의 범위
        - TLB 항목 수 * 페이지 크기

### TLB를 고려한 컨텍스트 스위칭 과정 재정리

- 동일 한 프로세스의 다른 스레드로 스위칭 되는 경우
    - TLB 항목 교체 필요 없음
- 다른 프로세스의 스레드로 스위칭되는 경우
    - TLB는 새로운 프로세스의 페이지 테이블 항목들로 교체되어야 함
    - 컨텍스트 스위칭 과정
        - CPU의 모든 레지스터를 TCB에 저장
        - ***새 프로세스의 PCB에 저장된 페이지 테이블의 주소를 CPU 내의 PTBR (page table base register)에 적재***
        - ***TLB의 모든 항목 지우기***
            - TLB miss 발생 → TLB에 항목 채우기 시작
        - 새로 스케줄된 스레드의 TCB에서 레지스터 값을 CPU에 적재
        

## 4. 심화 학습 : 페이지 테이블의 낭비 문제 해결

### 4.1 페이지 테이블의 메모리 낭비

- 페이지 테이블로 인해 메모리가 낭비되는 2가지 요인
    - 페이지 테이블의 일부 항목만 사용
    - 프로세스마다 페이지 테이블 존재

![Untitled](Untitled%2014.png)

- 페이지 테이블로 인한 메모리 낭비를 줄이는 방법
    - 역 페이지 테이블 IPT, inverted page table
    - 멀티레벨 페이지 테이블 multi-level page table

### 4.2 역 페이지 테이블

- 프레임을 중심으로 물리 메모리의 전체 프레임에 대해 각 프레임이 어떤 프로세스의 어떤 페이지에 할당되었는지 나타내는 테이블
- 프레임의 개수가 n이므로 역 페이지 테이블의 항목 개수도 n개로 구성된다.
- 시스템에 1개만 둔다.
- 역 페이지 테이블 항목
    - [ 프로세스 번호 pid, 페이지 번호 p ]
- 역 페이지 테이블의 인덱스
    - 프레임 번호
- 역 페이지 테이블을 사용할 때 논리 주소 형식
    - [ 프로세스 번호,  페이지 번호, 옵셋 ]
- 역 페이지 테이블을 사용한 주소 변환
    - 논리 주소에서 [ 프로세스 번호, 페이지 번호 ] 로 역 페이지 테이블 검색
    - 일치하는 항목 발견 시, 항목 번호가 바로 프레임 번호
    - 프레임 번호와 옵셋을 연결하면 물리 주소
    
    ![Untitled](Untitled%2015.png)
    
- 역 페이지 테이블의 크기
    - 시스템에 1개 존재
    - 역 페이지 테이블의 크기는 시스템에 설치된 물리 메모리의 크기에 따라 달라지므로 모든 시스템에서 동일할 수 없다.
    - 예시
    
    ![Untitled](Untitled%2016.png)
    

### 4.3 멀티레벨 페이지 테이블

- 프로세스가 현재 사용 중인 페이지들에 대해서만 페이지 테이블을 만드는 방식으로 페이지 테이블의 낭비를 줄인다.
- 수십~수백 개의 작은 페이지 테이블로 나누고 이들을 여러 level로 구성
- 2-레벨 페이지 테이블 구성
    - 프로세스의 주소 공간을 1024개의 테이블로 나누고, 1024개의 페이지를 1개의 페이지 테이블로 나타낸다. 그러므로 페이지 테이블의 항목은 1024개이다.
    - 논리 주소 구성
        - [ 페이지 디렉터리 인덱스, 페이지 테이블 인덱스, 옵셋 ]
        - 페이지 크기 4KB
        - 논리 주소 하위 12비트 : 페이지 내 옵셋 주소
        - 논리 주소 상위 20비트 : 페이지 디렉터리 인덱스 + 페이지 테이블 인덱스
        
        ![Untitled](Untitled%2017.png)
        
    - 2-레벨 페이지 테이블 사례
    
    ![Untitled](Untitled%2018.png)
    
    - 2-레벨 페이지 테이블이 형성되는 과정 p449 ~ 453
    
    ![Untitled](Untitled%2019.png)