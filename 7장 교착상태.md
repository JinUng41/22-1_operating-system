# 7장 교착상태

## 1. 교착상태 문제 제기

### 1.1 무한 대기와 교착상태

- ***교착상태***
    - 자원을 소유한 채, 상대방이 소유한 자원을 기다리면서 무한 대기하는 현상

### 1.2 식사하는 철학자 문제 Dining Philosophers Problem

- 네덜란드 아인트호벤 기술 대학의 Edger Dijkstra 에드거 다익스트라 교수는 1965년 병렬 처리 강의에서 동기화 문제와 해결 방법과 관련하여 다음과 같은 문제를 냄.

![Untitled](Untitled.png)

- 문제 요약
    - 5명의 철학자가 원탁에서 식사. 식사 시간은 서로 다를 수 있음
    - 자리마다 스파게티 그릇이 하나 있고 5개의 포크가 그릇 사이에 있음
    - 철학자는 다른 철학자와 대화할 수 없음
        - 대화할 수 없음 = 프로세스 간 통신 불가
    - 식사를 위해서는 양 옆의 포크를 함께 들어야 함
    - 왼쪽 포크를 먼저 든 다음 오른쪽 포크를 드는 순서이며 포크가 사용 중이면 대기해야 함, 왼쪽 포크를 옆 철학자가 사용하고 있다면 오른쪽 포크도 잡을 수 없음
- 문제가 발생하는 경우
    - 모두 거의 동시에 왼쪽 포크를 든 후 오른쪽 포크를 들려고 할 때, 모두 상대가 가진 포크를 기다리면서 먹을 수 없는 교착 상태 발생
    - 5명 모두 왼쪽 포크를 가지고 오른쪽 포크를 요청하는 ***환형 고리***
        - 환형 고리는 스스로 인식하거나 해체 불가
- 해결 방법
    - 원형 상태로 요청이 생기지 않게 함
    - 5명 중 마지막 사람을 제외한 4명이 왼쪽 포크를 먼저 잡고 오른쪽 포크를 잡는 순서로 진행하고, 마지막 사람은 오른쪽 포크를 먼저 잡고 왼쪽 포크를 잡는 순서로 진행
    
    ![Untitled](Untitled%201.png)
    

### 1.3 식사하는 철학자와 컴퓨터 시스템

교착 상태는 다중프로그래밍 시스템 초기에 발생한 문제점

- 철학자 - 프로세스
- 포크 - 자원
- 스파게티 - 프로세스가 처리할 작업

![Untitled](Untitled%202.png)

## 2. 교착상태

deadlock, deadly embrace 풀지 못하는 포옹

### 2.1 교착상태 정의

- ***교착상태***
    - ***자원을 소유한 스레드들 사이에서 각 스레드는 다른 스레드가 소유한 자원을 요청하여 모든 스레드가 무한정 대기하는 현상***
    - 락이나 자원에 대한 멀티스레드의 경쟁이 있는 한 발생할 수 있다.
    - 교착상태 문제는 1965년 Dijkstra의 banker’s algorithm research에서 처음으로 제기
    - 교착상태 발생 위치
        - 사용자가 작성한 멀티스레드 응용프로그램에서 주로 발생
            - 정교하지 못한 코딩에서 비롯
        - 커널 내에서도 발생
            - 하지만 거의 발생하지 않음, 정교하게 작성되었기 때문
        - 교착상태를 막기 위한 방법은 없음
            - 많은 시간과 공간 비용 때문
            - 따라서 교착 상태가 발생할 것 같으면, 시스템 재시작 혹은 의심 프로그램 종료함으로써 해결
- 전형적인 멀티스레드 교착 상태 사례
    - 2개의 스레드가 각각 락 소유, 상대가 가진 락 요청하고 기다릴 때
        - 단일/다중 CPU 모두에서 발생, T1과 T2가 서로 다른 CPU에서 실행될 때도 발생
    - 락과 자원에 대한 경쟁이 있는 한 교착상태는 언제든 발생 가능
    
    ![Untitled](Untitled%203.png)
    

### 2.2 컴퓨터 시스템에 잠재된 교착상태 유발 요인

- 자원은 교착 상태의 발생지
    - 교착상태는 멀티스레드가 자원을 동시에 사용하려는 충돌이 요인
    - 소프트웨어/데이터 자원
        - 뮤텍스, 스핀락, 세마포, 파일, 데이터베이스, 파일락 등
    - 하드웨어 자원
        - 프린터, 메모리, 프로세서 등
- 자원과 스레드
    - 한 스레드가 여러 자원을 동시에 필요로 하는 상황이 요인
- 자원과 운영체제
    - 한 번에 하나씩 자원을 할당하는 운영체제 정책이 요인
        - 만일 스레드가 필요한 자원을 한 번에 모두 요청하도록 한다면, 교착상태 발생하지 않게 할 수 있다.
- 자원 비선점
    - 할당된 자원은 스레드가 자발적으로 내놓기 전에 강제로 뺏지 못하는 정책

### 2.3 교착상태 모델링

- 자원 할당 그래프 Resource Allocation Graph, RAG
    - 그래프의 요소
        - 꼭지점 vertex - 스레드(원), 자원(사각형)
        - 간선 edge - 소유/요청 관계. 할당 간선과 요청 간선
            - 할당 간선 : 자원에서 스레드로 향하는 화살표, 할당 받은 상태 표시
            - 요청 간선 : 스레드에서 자원으로 향하는 화살표, 요청 표시
    - 시스템 내 자원들의 상태를 나타내는 방향성 그래프
        - 컴퓨터 시스템에 실행 중인 전체 스레드와 자원
        - 각 자원의 총 인스턴스 개수와 할당 가능한 인스턴스 개수
        - 각 스레드가 할당받아 소유하고 있는 자원의 인스턴스 개수
        - 각 스레드가 실행에 필요한 자원 유형과 인스턴스 개수
    
    ![Untitled](Untitled%204.png)
    
- 자원 할당 그래프를 통해 교착상태 판단
    - 교착상태 예방, 회피, 감지를 위한 알고리즘 개발에 필요
- 교착상태가 발생한 자원 할당 그래프
    
    ![Untitled](Untitled%205.png)
    

### 탐구 7-1 교착상태에 빠진 응용프로그램 사례 p363~365

## 3. 교착상태 해결

### 3.1 코프만 조건

- ***코프만 조건 Coffman condition***
    - 교착상태가 발생하는 ***4가지 필요충분 조건***
    - 4가지 조건을 모두 가진 컴퓨터 시스템에서는 언제든 교착상태가 발생할 수 있다.
        - 상호배체 mutual exclusion
            - 각 자원은 한 번에 하나의 스레드에게만 할당
        - 소유하면서 대기 hold & wait
            - 스레드가 자원을 소유하면서 다른 자원 대기
        - 강제 자원 반환 불가 no preemption
            - 스레드에게 할당된 자원을 강제로 빼앗지 못함
        - 환형 대기 circular wait
            - 한 그룹의 스레드들에 대해, 각 스레드는 다른 스레드가 요청하는 자원을 소유하는 환형 고리 형성
    - 4가지 조건 중 하나라도 성립되지 않으면, 교착상태 발생 X

### 3.2 교착상태 해결 방법

- 교착상태 예방 prevention
    - 교착상태 발생 여지를 차단하여 예방
    - 교착상태에 빠지는 코프만 조건 중 하나 이상의 조건이 성립되지 못하도록 시스템 구성
- 교착상태 회피 avoidance
    - 자원 할당 시마다 교착 상태 가능성을 검사하여 교착상태가 발생하지 않을 것이라고 확신하는 경우에만 자원 할당
- 교착상태 감지 및 복구 detection and recovery
    - 교착상태를 감지하는 프로그램을 백그라운드에서 구동, 발견 후 교착상태 해제
        - 백그라운드에서 항상 실행되어야 하는 부담
- 교착상태 무시 ignore and reboot
    - 교착상태에 대한 대비책 없음
    - 리눅스, 윈도우 등 현재 대부분의 운영체제에서 사용하는 가장 일반적인 방법
        - 예방, 회피, 감지 및 복구 등 많은 시간과 공간 비용이 필요 → 시스템 성능 저하
        - ***ostrich 알고리즘***

### 3.3 교착상태 예방

- 코프만의 4가지 조건 중 최소 하나를 성립하지 못하게 함
    - 상호 배체 조건 → 상호 배제 없애기
        - 동시에 2개 이상의 스레드가 자원을 활용할 수 있도록 함
        - 컴퓨터 시스템에서 근본적으로 적용 불가능한 방법
    - 소유하면서 대기 조건 → 기다리지 않게
        - 방법 1 : 운영체제는 스레드 실행 전 필요한 모든 자원을 파악하고 실행 시 한 번에 할당
            - 당장 사용하지 않는 자원을 스레드에게 묶어 두기 때문에 자원 활용률이 떨어짐
            - 다른 스레드는 필요한 자원을 할당 받지 못하고 실행 대기
        - 방법 2 : 스레드가 새로운 자원을 요청하려면, 현재 할당 받은 모든 자원을 반환하고, 한꺼번에 요청하여 할당
        - 방법 1과 방법 2 모두 가능하지 않거나 매우 비효율적임
    - 강제 자원 반환 불가 조건 → 선점 허용
        - 자원을 강제로 반환하게 된 스레드가 자원을 다시 사용하게 될 때 이전 상태로 되돌아갈 수 있도록 상태를 관리할 필요
        - 오버헤드 매우 큼
    - 환형 대기 조건 → 환형 대기 제거
        - 모든 자원에 번호를 매기고, ***번호순으로 자원 할당***
    
    ![Untitled](Untitled%206.png)
    

### 3.4 교착상태 회피

- 자원 할당 시, 미래에 환형 대기가 발생할 것으로 판단되면 자원 할당 하지 않는 정책
- ***banker’s 알고리즘***으로 해결
    - Edsgar Dijkstra에 의해 개발
    - 안전한 상태와 불안정한 상태(환형 대기)로 나누고
        - 안전한 상태에서만 자원을 할당
    - ***스레드의 실행 전에 필요한 자원의 개수를 아는 것은 사실상 불가능하므로 비현실적인 알고리즘***

### 3.5 교착상태 감지 및 복구

- 교착상태를 감지하는 프로그램을 통해, 형성된 교착상태를 푼다.
    - 백그라운드에서 항상 감지
- 교착 상태를 감지했을 때 복구 방법
    - 자원 강제 선점 preemption
    - ***롤백 rollback***
        - 가장 최근에 저장해둔 상태로 복구시켜 가장 최근에 실행하던 상태로 돌아가게 한다.
    - 스레드 강제 종료 kill process
- 시간과 메모리 공간(rollback의 경우)에 대한 부담이 커서 잘 사용하지 않는다.

### 3.6 교착상태 무시 : 타조 (ostrich) 알고리즘

- 교착상태는 반드시 발생하나 해결할 필요는 없다
- ***교착상태 무시 전략***
- 타조 알고리즘
    - ***put your head in the sand*** 접근법
        - ‘교착상태는 발생하지 않을 거야’하고 아무 대책을 취하지 않음
    - 현재 거의 모든 운영체제에서 사용
        - reboot 하거나, kill process 하거나
- 실시간 시스템 (핵, 비행기, 미사일 등)이나 환자 감시 시스템 등에서는 적합하지 않음
- Not everything worth doing is worth doing well
    - 할 만한 가치가 있는 일이라고 해서 모두 잘할 가치가 있는 것은 아니다.